module Network.OpenID.Simple (
    authenticate, verify, Session(..)
) where

import qualified Network.OpenID as ID
 
-- | Wrap up all the data necessary to do a verify into one place, plus some
--   extra useful stuff.
data Session = Session {
    -- | the authentication uri to send the client off to
    authURI :: String,
    -- | the OpenID provider as a string
    provider :: String,
    -- | the normalized OpenID identity as a string
    identity :: String,
    -- | the uri the client will come back to after authenticating
    returnTo :: String,
    -- | the association map manager thing uses internally
    assocMap :: ID.AssociationMap
} deriving (Read,Show)

-- | Given an identity and return uri,
--   contact the remote provider to create a Session object encapsulating the
--   useful bits of data to pass along to verify and also to pick out the
--   normalized identity from.
authenticate :: String -> String -> IO Session
authenticate ident returnTo = do
    -- this bit is heavily based on the old examples/test.hs
    normalizedIdent <- case ID.normalizeIdentifier (ID.Identifier ident) of
        Nothing -> fail "Unable to normalize identifier"
        Just ident -> return ident
    
    let resolve = ID.makeRequest True
    
    (provider,identifier) <- (=<< ID.discover resolve normalizedIdent)
        $ \x -> case x of
            Left err -> fail $ "Discovery Error: " ++ show err
            Right pi -> return pi
        :: IO (ID.Provider,ID.Identifier)
    
    am <- (=<< ID.associate ID.emptyAssociationMap True resolve provider)
        $ \x -> case x of
            Left err -> fail $ "Associate Error: " ++ show err
            Right a -> return a
    
    return $ Session {
        authURI = show $ ID.authenticationURI
            am ID.Setup provider identifier returnTo Nothing,
        provider = show $ ID.providerURI provider,
        identity = ID.getIdentifier identifier,
        returnTo = returnTo,
        assocMap = am
    }

-- | Given a Session generated by auth, and the uri that the
--   client came back on from the provider, make sure the client properly
--   authenticated by running verifyError on failure to verify the credentials.
verify :: Session -> String -> IO (Maybe String)
verify session uri = do
    verified <- ID.verifyAuthentication
        (assocMap session)
        (ID.parseParams uri)
        (returnTo session)
        (ID.makeRequest True)
    return $ case verified of
        Left err -> Just $ show err
        Right _ -> Nothing
